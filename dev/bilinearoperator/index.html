<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BilinearOperator · ExtendableFEM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li class="is-active"><a class="tocitem" href>BilinearOperator</a><ul class="internal"><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#DG-BilinearForms"><span>DG BilinearForms</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Other packages</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example103_BurgersEquation/">103 : Burger&#39;s Equation</a></li><li><a class="tocitem" href="../examples/Example105_NonlinearPoissonEquation/">105 : Nonlinear Poisson Equation</a></li><li><a class="tocitem" href="../examples/Example106_NonlinearDiffusion/">106 : Nonlinear Diffusion</a></li><li><a class="tocitem" href="../examples/Example108_RobinBoundaryCondition/">108 : Robin Boundary Condition</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem/">201 : Poisson-Problem</a></li><li><a class="tocitem" href="../examples/Example202_MixedPoissonProblem/">202 : Poisson-Problem (Mixed)</a></li><li><a class="tocitem" href="../examples/Example205_HeatEquation/">205 : Heat equation</a></li><li><a class="tocitem" href="../examples/Example210_LshapeAdaptivePoissonProblem/">210 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example211_LshapeAdaptiveEQPoissonProblem/">211 : Poisson L-shape Local Equilibrated Fluxes</a></li><li><a class="tocitem" href="../examples/Example220_ReactionConvectionDiffusion/">220 : Reaction-Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/Example225_ObstacleProblem/">225 : Obstacle Problem</a></li><li><a class="tocitem" href="../examples/Example230_NonlinearElasticity/">230 : Nonlinear Elasticity</a></li><li><a class="tocitem" href="../examples/Example235_StokesIteratedPenalty/">235 : Stokes iterated penalty method</a></li><li><a class="tocitem" href="../examples/Example240_SVRTEnrichment/">240 : Stokes <span>$RT$</span> enrichment</a></li><li><a class="tocitem" href="../examples/Example245_NSEFlowAroundCylinder/">245 : Flow around a cylinder</a></li><li><a class="tocitem" href="../examples/Example250_NSELidDrivenCavity/">250 : Navier–Stokes Lid-driven cavity</a></li><li><a class="tocitem" href="../examples/Example252_NSEPlanarLatticeFlow/">252 : Navier–Stokes Planar Lattice Flow</a></li><li><a class="tocitem" href="../examples/Example260_AxisymmetricNavierStokesProblem/">260 : Axisymmetric Stokes</a></li><li><a class="tocitem" href="../examples/Example265_FlowTransport/">265 : Flow + Transport</a></li><li><a class="tocitem" href="../examples/Example270_NaturalConvectionProblem/">270 : Natural convection</a></li><li><a class="tocitem" href="../examples/Example280_CompressibleStokes/">240 : Compressible Stokes 2D</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>BilinearOperator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BilinearOperator</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="github.com/chmerdon/ExtendableFEM.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BilinearOperator"><a class="docs-heading-anchor" href="#BilinearOperator">BilinearOperator</a><a id="BilinearOperator-1"></a><a class="docs-heading-anchor-permalink" href="#BilinearOperator" title="Permalink"></a></h1><p>A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the ground finite element space (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces. For all other discontinuous operator evaluations there is the possibility to use BilinerOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.BilinearOperator" href="#ExtendableFEM.BilinearOperator"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	A::AbstractMatrix,
	u_test,
	u_ansatz = u_test;
	kwargs...)</code></pre><p>Generates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments u<em>test and u</em>ansatz specify where to put the (blocks of the) matrix in the system.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.BilinearOperator" href="#ExtendableFEM.BilinearOperator"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;
	kwargs...)</code></pre><p>Generates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.BilinearOperator-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}" href="#ExtendableFEM.BilinearOperator-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	kernel::Function,
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_args::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, eval_args, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><h2 id="DG-BilinearForms"><a class="docs-heading-anchor" href="#DG-BilinearForms">DG BilinearForms</a><a id="DG-BilinearForms-1"></a><a class="docs-heading-anchor-permalink" href="#DG-BilinearForms" title="Permalink"></a></h2><p>BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions.</p><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.BilinearOperatorDG" href="#ExtendableFEM.BilinearOperatorDG"><code>ExtendableFEM.BilinearOperatorDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperatorDG(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;
	kwargs...)</code></pre><p>Generates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.</p><p>Keyword arguments:</p><ul><li><p>lump: lump the operator (= only assemble the diagonal). Default: false</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>callback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperatorDG&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>FACES). Default: ON</em>FACES</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}" href="#ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.BilinearOperatorDG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperatorDG(
	kernel::Function,
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_args::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, eval_args, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Below two examples illustrate some use cases.</p><h3 id="Example-Stokes-operator"><a class="docs-heading-anchor" href="#Example-Stokes-operator">Example - Stokes operator</a><a id="Example-Stokes-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Stokes-operator" title="Permalink"></a></h3><p>For the linear operator of a Stokes problem a kernel could look like</p><pre><code class="language-julia hljs">μ = 0.1 # viscosity parameter
function kernel!(result, input, qpinfo)
    ∇u, p = view(input,1:4), view(input, 5)
    result[1] = μ*∇u[1] - p[1]
    result[2] = μ*∇u[2]
    result[3] = μ*∇u[3]
    result[4] = μ*∇u[4] - p[1]
    result[5] = -(∇u[1] + ∇u[4])
    return nothing
end</code></pre><p>and the coressponding BilinearOperator constructor call reads</p><pre><code class="language-julia hljs">u = Unknown(&quot;u&quot;; name = &quot;velocity&quot;)
p = Unknown(&quot;p&quot;; name = &quot;pressure&quot;)
BilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)</code></pre><p>The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since <code>input[5]</code> does not couple with <code>result[5]</code>.</p><h3 id="Example-interior-penalty-stabilization"><a class="docs-heading-anchor" href="#Example-interior-penalty-stabilization">Example - interior penalty stabilization</a><a id="Example-interior-penalty-stabilization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-interior-penalty-stabilization" title="Permalink"></a></h3><p>A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel</p><pre><code class="language-julia hljs">function stab_kernel!(result, input, qpinfo)
    result .= input .* qpinfo.volume^2
end</code></pre><p>and the BilinearOperatorDG constructor call</p><pre><code class="language-julia hljs">u = Unknown(&quot;u&quot;)
assign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nonlinearoperator/">« NonlinearOperator</a><a class="docs-footer-nextpage" href="../linearoperator/">LinearOperator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 4 September 2023 11:32">Monday 4 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
