<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>265 : Flow + Transport · ExtendableFEM.jl</title><meta name="title" content="265 : Flow + Transport · ExtendableFEM.jl"/><meta property="og:title" content="265 : Flow + Transport · ExtendableFEM.jl"/><meta property="twitter:title" content="265 : Flow + Transport · ExtendableFEM.jl"/><meta name="description" content="Documentation for ExtendableFEM.jl."/><meta property="og:description" content="Documentation for ExtendableFEM.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEM.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ExtendableFEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../../nonlinearoperator/">NonlinearOperator</a></li><li><a class="tocitem" href="../../bilinearoperator/">BilinearOperator</a></li><li><a class="tocitem" href="../../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../../callbackoperator/">CallbackOperator</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../../pdesolvers/">Stationary Solvers</a></li><li><a class="tocitem" href="../../pdesolvers_dt/">Time-dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../../postprocessing/">Other packages</a></li><li><a class="tocitem" href="../../itemintegrators/">Item Integrators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../Example103_BurgersEquation/">103 : Burger&#39;s Equation</a></li><li><a class="tocitem" href="../Example105_NonlinearPoissonEquation/">105 : Nonlinear Poisson Equation</a></li><li><a class="tocitem" href="../Example106_NonlinearDiffusion/">106 : Nonlinear Diffusion</a></li><li><a class="tocitem" href="../Example108_RobinBoundaryCondition/">108 : Robin Boundary Condition</a></li><li><a class="tocitem" href="../Example201_PoissonProblem/">201 : Poisson-Problem</a></li><li><a class="tocitem" href="../Example202_MixedPoissonProblem/">202 : Poisson-Problem (Mixed)</a></li><li><a class="tocitem" href="../Example204_LaplaceEVProblem/">204 : Eigenvalue problem for the Laplacian</a></li><li><a class="tocitem" href="../Example205_HeatEquation/">205 : Heat equation</a></li><li><a class="tocitem" href="../Example210_LshapeAdaptivePoissonProblem/">210 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../Example211_LshapeAdaptiveEQPoissonProblem/">211 : Poisson L-shape Local Equilibrated Fluxes</a></li><li><a class="tocitem" href="../Example220_ReactionConvectionDiffusion/">220 : Reaction-Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../Example225_ObstacleProblem/">225 : Obstacle Problem</a></li><li><a class="tocitem" href="../Example230_NonlinearElasticity/">230 : Nonlinear Elasticity</a></li><li><a class="tocitem" href="../Example235_StokesIteratedPenalty/">235 : Stokes iterated penalty method</a></li><li><a class="tocitem" href="../Example240_SVRTEnrichment/">240 : Stokes <span>$RT$</span> enrichment</a></li><li><a class="tocitem" href="../Example245_NSEFlowAroundCylinder/">245 : Flow around a cylinder</a></li><li><a class="tocitem" href="../Example250_NSELidDrivenCavity/">250 : Navier–Stokes Lid-driven cavity</a></li><li><a class="tocitem" href="../Example252_NSEPlanarLatticeFlow/">252 : Navier–Stokes Planar Lattice Flow</a></li><li><a class="tocitem" href="../Example260_AxisymmetricNavierStokesProblem/">260 : Axisymmetric Stokes</a></li><li class="is-active"><a class="tocitem" href>265 : Flow + Transport</a></li><li><a class="tocitem" href="../Example270_NaturalConvectionProblem/">270 : Natural convection</a></li><li><a class="tocitem" href="../Example275_OptimalControlStokes/">275 : Optimal Control Stokes</a></li><li><a class="tocitem" href="../Example280_CompressibleStokes/">280 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../Example290_PoroElasticity/">290 : Poro-Elasticity</a></li><li><a class="tocitem" href="../Example301_PoissonProblem/">201 : Poisson-Problem</a></li><li><a class="tocitem" href="../Example310_DivFreeBasis/">310 : Div-free RT0 basis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>265 : Flow + Transport</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>265 : Flow + Transport</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/chmerdon/ExtendableFEM.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id=":-Flow-Transport"><a class="docs-heading-anchor" href="#:-Flow-Transport">265 : Flow + Transport</a><a id=":-Flow-Transport-1"></a><a class="docs-heading-anchor-permalink" href="#:-Flow-Transport" title="Permalink"></a></h1><p>(<a href="https://github.com/chmerdon/ExtendableFEM.jl/raw/master/examples/Example265_FlowTransport.jl">source code</a>)</p><p>This example solve the Stokes problem in an Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity <span>$\mathbf{u}$</span>, a pressure <span>$\mathbf{p}$</span> and a stationary species concentration <span>$\mathbf{c}$</span> such that</p><p class="math-container">\[\begin{aligned}
- \mu \Delta \mathbf{u} + \nabla p &amp; = 0\\
\mathrm{div}(\mathbf{u}) &amp; = 0\\
\mathbf{c}_t - \kappa \Delta \mathbf{c} + \mathbf{u} \cdot \nabla \mathbf{c} &amp; = 0
\end{aligned}\]</p><p>with some viscosity parameter and diffusion parameter <span>$\kappa$</span>.</p><p>The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation three possibilities can be chosen:</p><ol><li>Classical Bernardi–Raugel stationary finite element discretisations <span>$\mathbf{u}_h \cdot \nabla \mathbf{c}_h$</span> [set FVtransport = false, reconstruct = false]</li><li>As in 1. but with divergence-free reconstruction operator in convection term <span>$\Pi_\text{reconst} \mathbf{u}_h \cdot \nabla \mathbf{c}_h$</span> [set FVtransport = false, reconstruct = true]</li><li>Time-dependent upwind finite volume discretisation for <span>$\kappa = 0$</span> based on normal fluxes along the faces [set FVtransport = true]</li></ol><p>Observe that the divergence-free postprocessing helps a lot for mass conservation, but is still not perfect. The finite volume upwind discretisation ensures mass conservation.</p><p>Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero <span>$\kappa$</span>). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.</p><pre><code class="language-julia hljs">module Example265_FlowTransport

using ExtendableFEM
using ExtendableFEMBase
using ExtendableSparse
using ExtendableGrids
using SimplexGridFactory
using Triangulate
using GridVisualize

# boundary data
function u_inlet!(result, qpinfo)
    x = qpinfo.x
    result[1] = 4*x[2]*(1-x[2])
    result[2] = 0
end
function c_inlet!(result, qpinfo)
    result[1] = (1-qpinfo.x[2])*qpinfo.x[2]
end

function kernel_stokes_standard!(result, u_ops, qpinfo)
    ∇u, p = view(u_ops,1:4), view(u_ops, 5)
    μ = qpinfo.params[1]
    result[1] = μ*∇u[1] - p[1]
    result[2] = μ*∇u[2]
    result[3] = μ*∇u[3]
    result[4] = μ*∇u[4] - p[1]
    result[5] = -(∇u[1] + ∇u[4])
end

function kernel_convection!(result, ∇T, u, qpinfo)
    result[1] = ∇T[1]*u[1] + ∇T[2]*u[2]
end

function kernel_inlet!(result, input, qpinfo)
    c_inlet!(result, qpinfo)
    result[1] *= -input[1]
end


# everything is wrapped in a main function
function main(; nrefs = 4, Plotter = nothing, reconstruct = true, FVtransport = true, μ = 1, kwargs...)

    # load mesh and refine
    xgrid = uniform_refine(simplexgrid(Triangulate;
    points = [0 0; 3 0; 3 -3; 7 -3; 7 0; 10 0; 10 1; 6 1; 6 -2; 4 -2; 4 1; 0 1]&#39;,
    bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 12; 12 1]&#39;,
    bfaceregions = [1; 1; 1; 1; 1; 2; 3; 3; 3; 3; 3; 4],
    regionpoints = [0.5 0.5;]&#39;,
    regionnumbers = [1],
    regionvolumes = [1.0]), nrefs)

    # define unknowns
    u = Unknown(&quot;u&quot;; name = &quot;velocity&quot;, dim = 2)
    p = Unknown(&quot;p&quot;; name = &quot;pressure&quot;, dim = 1)
    T = Unknown(&quot;T&quot;; name = &quot;temperature&quot;, dim = 1)

    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)

    # define first sub-problem: Stokes equations to solve for velocity u
    PD = ProblemDescription(&quot;Stokes problem&quot;)
    assign_unknown!(PD, u)
    assign_unknown!(PD, p)
    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))
    assign_operator!(PD, InterpolateBoundaryData(u, u_inlet!; regions = 4, kwargs...))
    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1,3], kwargs...))

    # add transport equation of species
    PDT = ProblemDescription(&quot;transport problem&quot;)
    assign_unknown!(PDT, T)
    if FVtransport ## FVM discretisation of transport equation (pure upwind convection)
        τ = 1e3
        assign_operator!(PDT, CallbackOperator(assemble_fv_operator!(), [u]; kwargs...))
        assign_operator!(PDT, BilinearOperator([id(T)]; store = true, factor = 1/τ, kwargs...))
        assign_operator!(PDT, LinearOperator([id(T)], [id(T)]; factor = 1/τ, kwargs...))
    else ## FEM discretisation of transport equation (with small diffusion term)
        assign_operator!(PDT, BilinearOperator([grad(T)]; factor = 1e-6, kwargs...))
        assign_operator!(PDT, BilinearOperator(kernel_convection!, [id(T)], [grad(T)], [id_u]; kwargs...))
        assign_operator!(PDT, InterpolateBoundaryData(T, c_inlet!; regions = [4], kwargs...))
    end

    # generate FESpaces and a solution vector for all 3 unknowns
    FETypes = [H1BR{2}, L2P0{1}, FVtransport ? L2P0{1} : H1P1{1}]
    FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 3]
    sol = FEVector(FES; tags = [u,p,T])

    # solve the two problems separately
    sol = solve(PD; init = sol, kwargs...)
    sol = solve(PDT; init = sol, maxiterations = 20, target_residual = 1e-12, constant_matrix = true, kwargs...)

    # print minimal and maximal concentration to check max principle (shoule be in [0,1])
    println(&quot;\n[min(c),max(c)] = [$(minimum(view(sol[T]))),$(maximum(view(sol[T])))]&quot;)

    # plot
    p = GridVisualizer(; Plotter = Plotter, layout = (2,1), clear = true, size = (800,800))
    scalarplot!(p[1,1],xgrid, view(nodevalues(sol[u]; abs = true),1,:), levels = 0, colorbarticks = 7)
    vectorplot!(p[1,1],xgrid, eval_func(PointEvaluator([id(u)], sol)), spacing = 0.25, clear = false, title = &quot;u_h (abs + quiver)&quot;)
    scalarplot!(p[2,1],xgrid, view(nodevalues(sol[T]),1,:), limits = (0,0.25), levels = 11, title = &quot;c_h&quot;)
end

# pure convection finite volume operator for transport
function assemble_fv_operator!()

    BndFluxIntegrator = ItemIntegrator(kernel_inflow!, [normalflux(1)]; entities = ON_BFACES)
    FluxIntegrator = ItemIntegrator([normalflux(1)]; entities = ON_FACES)
    fluxes::Matrix{Float64} = zeros(Float64,1,0)

    function closure(A, b, args; assemble_matrix = true, assemble_rhs = true, kwargs...)

    # prepare grid and stash
    xgrid = args[1].FES.xgrid
    nfaces = size(xgrid[FaceCells],2)
    if size(fluxes,2) &lt; nfaces
        fluxes = zeros(Float64, 1, nfaces)
    end

    # right-hand side = boundary inflow fluxes if velocity points inward
    if assemble_rhs
        fill!(fluxes, 0)
        evaluate!(fluxes, BndFluxIntegrator, [args[1]])
        facecells = xgrid[FaceCells]
        bface2face = xgrid[BFaceFaces]
        for bface in 1 : lastindex(bface2face)
            b[facecells[1, bface2face[bface]]] -= fluxes[bface]
        end
    end

    # assemble upwind finite volume fluxes over cell faces into matrix
    if assemble_matrix
        # integrate normalfux of velocity
        fill!(fluxes, 0)
        evaluate!(fluxes, FluxIntegrator, [args[1]])

        cellfaces = xgrid[CellFaces]
        cellfacesigns = xgrid[CellFaceSigns]
        for cell = 1 : num_cells(xgrid)
            nfaces4cell = num_targets(cellfaces, cell)
            for cf = 1 : nfaces4cell
                face = cellfaces[cf,cell]
                other_cell = facecells[1,face]
                if other_cell == cell
                    other_cell = facecells[2,face]
                end
                flux = fluxes[face] * cellfacesigns[cf,cell]
                if (other_cell &gt; 0)
                    flux *= 1 // 2 # because it will be accumulated on two cells
                end
                if flux &gt; 0 # flow from cell to other_cell or out of domain
                    _addnz(A,cell,cell,flux,1)
                    if other_cell &gt; 0
                        _addnz(A,other_cell,cell,-flux,1)
                        # otherwise flow goes out of domain
                    end
                else # flow from other_cell into cell or into domain
                    _addnz(A,cell,cell,1e-16,1) # add zero to keep pattern for LU
                    if other_cell &gt; 0 # flow comes from neighbour cell
                        _addnz(A,other_cell,other_cell,-flux,1)
                        _addnz(A,cell,other_cell,flux,1)
                    end
                    # otherwise flow comes from outside into domain, handled in rhs side loop above
                end
            end
        end
    end
    return nothing
    end
end


function kernel_inflow!(result, input, qpinfo)
    if input[1] &lt; 0 # if velocity points into domain
        c_inlet!(result, qpinfo)
        result[1] *= input[1]
    else
        result[1] = 0
    end
end



end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><p><strong>Default output:</strong></p><pre><code class="nohighlight hljs">julia&gt; Example265_FlowTransport.main()
 #IT	------- RESIDUALS -------	---- DURATION (s) ----		---- ALLOCATIONS (MiB) ----
   	NONLINEAR	LINEAR		ASSEMB	SOLVE	TOTAL		ASSEMB	SOLVE	TOTAL
 INI							0.00				0.76
 END	---------	1.034e-11	0.10	0.18	0.27		13.93	51.23	65.16
	finished				SUM --&gt;	0.28			SUM --&gt;	65.93

 #IT	------- RESIDUALS -------	---- DURATION (s) ----		---- ALLOCATIONS (MiB) ----
   	NONLINEAR	LINEAR		ASSEMB	SOLVE	TOTAL		ASSEMB	SOLVE	TOTAL
 INI							0.00				0.73
   1	3.976e-02	8.049e-17	0.01	0.00	0.01		1.51	3.35	4.86
   2	4.264e-05	8.455e-17	0.00	0.00	0.00		0.00	0.00	0.01
   3	7.825e-07	8.441e-17	0.00	0.00	0.00		0.00	0.00	0.01
   4	5.955e-08	8.496e-17	0.00	0.00	0.00		0.00	0.00	0.01
   5	1.002e-08	8.501e-17	0.00	0.00	0.00		0.00	0.00	0.01
   6	1.709e-09	8.459e-17	0.00	0.00	0.00		0.00	0.00	0.01
   7	2.860e-10	8.361e-17	0.00	0.00	0.00		0.00	0.00	0.01
   8	4.728e-11	8.466e-17	0.00	0.00	0.00		0.00	0.00	0.01
   9	7.766e-12	8.670e-17	0.00	0.00	0.00		0.00	0.00	0.01
  10	1.271e-12	8.637e-17	0.00	0.00	0.00		0.00	0.00	0.01
 END	2.077e-13			0.00		0.00		0.00		0.00
	converged				SUM --&gt;	0.02			SUM --&gt;	5.63


[min(c),max(c)] = [0.03950832201086902,0.24870388160205545]</code></pre><p><img src="../../images/Example265_FlowTransport_1.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Example260_AxisymmetricNavierStokesProblem/">« 260 : Axisymmetric Stokes</a><a class="docs-footer-nextpage" href="../Example270_NaturalConvectionProblem/">270 : Natural convection »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Thursday 21 September 2023 15:43">Thursday 21 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
